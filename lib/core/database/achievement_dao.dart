import 'package:drift/drift.dart';
import 'app_database.dart';

part 'achievement_dao.g.dart';

// ===== ACHIEVEMENT DAO =====

@DriftAccessor(tables: [Achievements])
class AchievementDao extends DatabaseAccessor<AppDatabase>
    with _$AchievementDaoMixin {
  AchievementDao(super.db);

  // Access to table instances - these should be generated by Drift
  @override
  late final $AchievementsTable achievements = attachedDatabase.achievements;

  /// Convert string profile ID to integer ID consistently
  int _convertProfileId(String id) {
    if (id == 'default_user') return 1;
    return int.tryParse(id) ?? 1;
  }

  // ===== ACHIEVEMENT OPERATIONS =====

  /// Get all achievements for a profile
  Future<List<Achievement>> getAchievementsByProfile(String profileId) {
    final intId = _convertProfileId(profileId);

    return (select(achievements)
          ..where((a) => a.profileId.equals(intId))
          ..orderBy([(a) => OrderingTerm.desc(a.unlockedDate)]))
        .get();
  }

  /// Watch achievements for a profile reactively
  Stream<List<Achievement>> watchAchievements(String profileId) {
    final intId = _convertProfileId(profileId);

    return (select(achievements)
          ..where((a) => a.profileId.equals(intId))
          ..orderBy([(a) => OrderingTerm.desc(a.unlockedDate)]))
        .watch();
  }

  /// Get a specific achievement for a profile
  Future<Achievement?> getAchievement(String profileId, String achievementId) {
    final intId = _convertProfileId(profileId);

    return (select(achievements)..where(
          (a) =>
              a.profileId.equals(intId) & a.achievementId.equals(achievementId),
        ))
        .getSingleOrNull();
  }

  /// Unlock an achievement for a profile
  Future<int> unlockAchievement(String profileId, String achievementId) {
    final intId = _convertProfileId(profileId);

    return (update(achievements)..where(
          (a) =>
              a.profileId.equals(intId) & a.achievementId.equals(achievementId),
        ))
        .write(
          AchievementsCompanion(
            isUnlocked: const Value(true),
            unlockedDate: Value(DateTime.now()),
          ),
        );
  }

  /// Update achievement progress for a profile
  Future<int> updateProgress(
    String profileId,
    String achievementId,
    int progress,
  ) {
    final intId = _convertProfileId(profileId);

    return (update(achievements)..where(
          (a) =>
              a.profileId.equals(intId) & a.achievementId.equals(achievementId),
        ))
        .write(AchievementsCompanion(progress: Value(progress)));
  }

  /// Update achievement progress (alias for updateProgress for backward compatibility)
  Future<int> updateAchievementProgress(
    String profileId,
    String achievementId,
    int progress,
  ) {
    return updateProgress(profileId, achievementId, progress);
  }

  /// Set achievement progress and unlock if complete
  Future<bool> setProgressAndCheckUnlock(
    String profileId,
    String achievementId,
    int progress,
    int maxProgress,
  ) async {
    final intId = _convertProfileId(profileId);

    final updated =
        await (update(achievements)..where(
              (a) =>
                  a.profileId.equals(intId) &
                  a.achievementId.equals(achievementId),
            ))
            .write(AchievementsCompanion(progress: Value(progress)));

    // Check if achievement should be unlocked
    if (progress >= maxProgress) {
      await unlockAchievement(profileId, achievementId);
    }

    return updated > 0 || progress >= maxProgress;
  }

  /// Insert a new achievement record (used during profile creation)
  Future<int> insertAchievement(AchievementsCompanion achievement) {
    return into(achievements).insert(achievement);
  }

  /// Initialize all achievements for a new profile
  Future<void> initializeAchievementsForProfile(String profileId) async {
    final intId = _convertProfileId(profileId);

    // Import the achievement data service to get all achievement IDs
    // This would typically come from a predefined list of achievements
    final achievementIds = [
      'first_win',
      'win_streak_3',
      'win_streak_5',
      'win_streak_10',
      'perfect_game',
      'robot_easy',
      'robot_medium',
      'robot_hard',
      'robot_legendary',
      'board_explorer',
      'board_master',
      'win_condition_explorer',
      'win_condition_master',
      'local_player',
      'centurion',
      'legend',
      'comeback_kid',
      'underdog',
    ];

    // First, check which achievements already exist to avoid duplicates
    final existingAchievements =
        await (select(achievements)
              ..where((a) => a.profileId.equals(intId))
              ..where((a) => a.achievementId.isIn(achievementIds)))
            .get();

    final existingIds = existingAchievements
        .map((a) => a.achievementId)
        .toSet();
    final missingIds = achievementIds
        .where((id) => !existingIds.contains(id))
        .toList();

    // Only insert achievements that don't already exist
    if (missingIds.isNotEmpty) {
      await batch((batch) {
        for (final achievementId in missingIds) {
          batch.insert(
            achievements,
            AchievementsCompanion(
              profileId: Value(intId),
              achievementId: Value(achievementId),
              isUnlocked: const Value(false),
              progress: const Value(0),
            ),
          );
        }
      });
    }
  }

  /// Get unlocked achievements count for a profile
  Future<int> getUnlockedCount(String profileId) async {
    final intId = _convertProfileId(profileId);

    final unlockedAchievements =
        await (select(achievements)..where(
              (a) => a.profileId.equals(intId) & a.isUnlocked.equals(true),
            ))
            .get();
    return unlockedAchievements.length;
  }

  /// Get total achievements count for a profile
  Future<int> getTotalCount(String profileId) async {
    final intId = _convertProfileId(profileId);

    final totalAchievements = await (select(
      achievements,
    )..where((a) => a.profileId.equals(intId))).get();
    return totalAchievements.length;
  }

  /// Check if achievement is unlocked
  Future<bool> isAchievementUnlocked(
    String profileId,
    String achievementId,
  ) async {
    final intId = _convertProfileId(profileId);

    final achievement =
        await (select(achievements)..where(
              (a) =>
                  a.profileId.equals(intId) &
                  a.achievementId.equals(achievementId),
            ))
            .getSingleOrNull();
    return achievement?.isUnlocked ?? false;
  }
}
