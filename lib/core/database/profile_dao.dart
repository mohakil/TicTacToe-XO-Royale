import 'package:drift/drift.dart';
import 'package:tictactoe_xo_royale/core/exceptions/database_exceptions.dart';
import 'app_database.dart';

part 'profile_dao.g.dart';

// ===== PROFILE DAO =====

@DriftAccessor(tables: [PlayerProfiles, PlayerStats])
class ProfileDao extends DatabaseAccessor<AppDatabase> with _$ProfileDaoMixin {
  ProfileDao(super.db);

  // Access to table instances - these should be generated by Drift
  @override
  late final $PlayerProfilesTable playerProfiles =
      attachedDatabase.playerProfiles;
  @override
  late final $PlayerStatsTable playerStats = attachedDatabase.playerStats;

  // ===== PROFILE OPERATIONS =====

  /// Convert string profile ID to integer ID consistently
  int _convertProfileId(String id) {
    if (id == 'default_user') return 1;
    return int.tryParse(id) ?? 1;
  }

  /// Get a single profile by ID
  Future<PlayerProfile?> getProfile(String id) {
    final intId = _convertProfileId(id);

    return (select(
      playerProfiles,
    )..where((p) => p.id.equals(intId))).getSingleOrNull();
  }

  /// Watch a profile reactively
  Stream<PlayerProfile?> watchProfile(String id) {
    final intId = _convertProfileId(id);

    return (select(
      playerProfiles,
    )..where((p) => p.id.equals(intId))).watchSingleOrNull();
  }

  /// Insert a new profile with validation
  Future<int> insertProfile(PlayerProfilesCompanion profile) {
    // Validate profile data before insertion
    _validateProfileData(profile);
    return into(playerProfiles).insert(profile);
  }

  /// Update an existing profile with validation
  Future<bool> updateProfile(PlayerProfile profile) {
    // Validate profile data before update
    _validateProfileDataForUpdate(profile);
    return update(playerProfiles).replace(profile);
  }

  /// Validate profile data
  void _validateProfileData(PlayerProfilesCompanion profile) {
    final nickname = profile.nickname.value;
    if (nickname.trim().isEmpty) {
      throw DatabaseValidationException(
        field: 'nickname',
        invalidValue: nickname,
        message: 'Profile nickname cannot be empty',
      );
    }

    final gems = profile.gems.value;
    if (gems < 0) {
      throw DatabaseValidationException(
        field: 'gems',
        invalidValue: gems,
        message: 'Profile gems cannot be negative',
      );
    }

    final hints = profile.hints.value;
    if (hints < 0) {
      throw DatabaseValidationException(
        field: 'hints',
        invalidValue: hints,
        message: 'Profile hints cannot be negative',
      );
    }
  }

  /// Validate profile data for updates
  void _validateProfileDataForUpdate(PlayerProfile profile) {
    if (profile.nickname.trim().isEmpty) {
      throw DatabaseValidationException(
        field: 'nickname',
        invalidValue: '',
        message: 'Profile nickname cannot be empty',
      );
    }

    if (profile.gems < 0) {
      throw DatabaseValidationException(
        field: 'gems',
        invalidValue: profile.gems,
        message: 'Profile gems cannot be negative',
      );
    }

    if (profile.hints < 0) {
      throw DatabaseValidationException(
        field: 'hints',
        invalidValue: profile.hints,
        message: 'Profile hints cannot be negative',
      );
    }
  }

  /// Delete a profile
  Future<int> deleteProfile(String id) {
    final intId = _convertProfileId(id);

    return (delete(playerProfiles)..where((p) => p.id.equals(intId))).go();
  }

  // ===== STATS OPERATIONS =====

  /// Get stats for a profile
  Future<PlayerStat?> getStats(String profileId) {
    final intId = _convertProfileId(profileId);

    return (select(
      playerStats,
    )..where((s) => s.profileId.equals(intId))).getSingleOrNull();
  }

  /// Update stats for a profile
  Future<int> updateStats(String profileId, PlayerStatsCompanion stats) {
    final intId = _convertProfileId(profileId);

    return (update(
      playerStats,
    )..where((s) => s.profileId.equals(intId))).write(stats);
  }

  /// Insert stats for a profile (used when creating new profile)
  Future<int> insertStats(PlayerStatsCompanion stats) {
    return into(playerStats).insert(stats);
  }

  // ===== COMBINED OPERATIONS =====

  /// Get profile with stats in a single query
  Future<PlayerProfileWithStats?> getProfileWithStats(String profileId) async {
    final profileIdInt = _convertProfileId(profileId);

    final result = await (select(playerProfiles).join([
      leftOuterJoin(
        playerStats,
        playerStats.profileId.equalsExp(playerProfiles.id),
      ),
    ])..where(playerProfiles.id.equals(profileIdInt))).getSingleOrNull();

    if (result == null) return null;

    return PlayerProfileWithStats(
      profile: result.readTable(playerProfiles),
      stats: result.readTableOrNull(playerStats),
    );
  }

  // ===== MANAGER API EXAMPLES (Drift v2.18+ - PREFERRED) =====

  /// Get profile by ID using Manager API (simplified syntax)
  Future<PlayerProfile?> getProfileByIdManager(String profileId) {
    final intId = _convertProfileId(profileId);
    return db.managers.playerProfiles
        .filter((p) => p.id.equals(intId))
        .getSingleOrNull();
  }

  /// Watch profile reactively using Manager API
  Stream<PlayerProfile?> watchProfileManager(String profileId) {
    final intId = _convertProfileId(profileId);
    return db.managers.playerProfiles
        .filter((p) => p.id.equals(intId))
        .watchSingleOrNull();
  }

  /// Count active profiles using Manager API
  Future<int> countActiveProfiles() {
    return db.managers.playerProfiles.count();
  }

  /// Get recent profiles with pagination using Manager API
  Future<List<PlayerProfile>> getRecentProfilesManager({int limit = 10}) {
    return db.managers.playerProfiles
        .orderBy((p) => p.createdAt.desc())
        .limit(limit)
        .get();
  }

  /// Update profile gems using Manager API
  Future<void> updateGemsManager(String profileId, int gems) {
    final intId = _convertProfileId(profileId);
    return db.managers.playerProfiles
        .filter((p) => p.id.equals(intId))
        .update((p) => PlayerProfilesCompanion(gems: Value(gems)));
  }

  /// Create a new profile with default stats
  Future<int> createProfileWithStats(PlayerProfilesCompanion profile) async {
    final profileId = await transaction(() async {
      // Insert profile
      final id = await into(playerProfiles).insert(profile);

      // Insert default stats
      await into(playerStats).insert(
        PlayerStatsCompanion(
          profileId: Value(id),
          wins: const Value(0),
          losses: const Value(0),
          draws: const Value(0),
          streak: const Value(0),
          totalGames: const Value(0),
        ),
      );

      return id;
    });

    return profileId;
  }

  /// Update profile and stats atomically
  Future<void> updateProfileAndStats(
    PlayerProfile profile,
    PlayerStatsCompanion stats,
  ) async {
    await transaction(() async {
      // Update profile
      await update(playerProfiles).replace(profile);

      // Update stats
      await (update(
        playerStats,
      )..where((s) => s.profileId.equals(profile.id))).write(stats);
    });
  }

  /// Update profile gems, stats, and achievements atomically
  Future<void> updateProfileWithAchievements(
    PlayerProfile profile,
    PlayerStatsCompanion stats,
    List<AchievementsCompanion> achievementUpdates,
  ) async {
    await transaction(() async {
      // Update profile
      await update(playerProfiles).replace(profile);

      // Update stats
      await (update(
        playerStats,
      )..where((s) => s.profileId.equals(profile.id))).write(stats);

      // Update achievements using the Achievements table
      for (final achievementUpdate in achievementUpdates) {
        await update(db.achievements).write(achievementUpdate);
      }
    });
  }
}

// ===== DATA CLASSES FOR JOINED QUERIES =====

class PlayerProfileWithStats {
  final PlayerProfile profile;
  final PlayerStat? stats;

  PlayerProfileWithStats({required this.profile, this.stats});
}
